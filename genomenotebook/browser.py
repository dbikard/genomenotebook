# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/API/00_browser.ipynb.

# %% auto 0
__all__ = ['GenomeBrowser']

# %% ../nbs/API/00_browser.ipynb 5
from fastcore.basics import *

from genomenotebook.utils import (
    parse_gff,
    in_wsl,
    add_extension,
)

from genomenotebook.glyphs import (
    get_feature_patches, 
    get_default_glyphs,
)

from genomenotebook.javascript import (
    x_range_change_callback_code,
    glyph_update_callback_code,
    search_callback_code,
    sequence_search_code,
    next_button_code,
    previous_button_code
)

from bokeh.models.tools import BoxZoomTool
from bokeh.models.glyphs import Patches

from bokeh.models import (
    CustomJS,
    Range1d,
    ColumnDataSource,
    AutocompleteInput,
    TextInput,
    Button,
    Rect,
    Div,
    Styles,
    TablerIcon,
    HoverTool, 
    NumeralTickFormatter, 
    LabelSet,
    HoverTool,
    Quad
)

from bokeh.plotting import figure
from bokeh.plotting import show as bk_show #Need to rename the bokeh show function so that there is no confusion with GenomeBrowser.show
from bokeh.layouts import column, row

from Bio import SeqIO

import numpy as np
import pandas as pd
import warnings


# %% ../nbs/API/00_browser.ipynb 6
class GenomeBrowser:
    """Initialize a GenomeBrowser object.
    """
    def __init__(self,
                 gff_path: str, #path to the gff3 file of the annotations (also accepts gzip files)
                 genome_path: str = None, #path to the fasta file of the genome sequence
                 seq_id: str = None, #id of the sequence to show for genomes with multiple contigs
                 init_pos: int = None, #initial position to display
                 init_win: int = 10000, #initial window size (max=20000)
                 bounds: tuple = None, #bounds can be specified. This helps preserve memory by not loading the whole genome if not needed.
                 max_interval: int = 100000, #maximum size of the field of view in bp
                 show_seq: bool = True, #shows the sequence when zooming in
                 search: bool = True, #enables a search bar
                 attributes: list = ["gene", "locus_tag", "product"], #list of attribute names from the GFF attributes column to be extracted
                 feature_name: str = "gene", #attribute to be displayed as the feature name
                 feature_types: list = ["CDS", "repeat_region", "ncRNA", "rRNA", "tRNA"], # list of feature types to display
                 glyphs: dict = None, #dictionnary defining the type and color of glyphs to display for each feature type
                 height: int = 150, # height of the annotation track
                 width: int = 600, # width of the inner frame of the browser
                 label_angle: int = 45, # angle of the feature names displayed on top of the features
                 label_font_size: str = "10pt", # font size fo the feature names
                 feature_height: float = 0.15, #fraction of the annotation track height occupied by the features
                 output_backend: str ="webgl", #can be "webgl" or "svg". webgl is more efficient but svg is a vectorial format that can be conveniently modified using other software
                 **kwargs, #additional keyword arguments are passed as is to bokeh.plotting.figure
                 ):
        
        self.gff_path = gff_path
        self.genome_path = genome_path
        self.show_seq = show_seq if genome_path!=None else False
        self.attributes = attributes
        self.feature_types = feature_types
        self.feature_name = feature_name
        self.feature_height = feature_height
        self.glyphs = get_default_glyphs() if glyphs==None else glyphs
        self.output_backend=output_backend
        self.label_angle=label_angle
        self.label_font_size=label_font_size
        self.height=height
        self.bounds=bounds
        self.max_interval=max_interval
        self.search=search
        self.init_pos=init_pos
        self.init_win=init_win
        self.frame_width = width
        self.kwargs=kwargs
        self.max_glyph_loading_range = 20000

        self.features = parse_gff(gff_path,
                                seq_id=seq_id,
                                bounds=bounds,
                                feature_types=feature_types
                                )
        
        if len(self.features)>0:
            self._prepare_data()
            self._get_gene_track()
            
    def _prepare_data(self):
        if self.feature_name not in self.features.columns:
            self.features[self.feature_name]=""

        self.seq_id = self.features.seq_id[0]
        self._get_sequence()

        if self.bounds == None: self.bounds=(0,self.seq_len)

        self.patches = get_feature_patches(self.features, 
                                            self.bounds[0], 
                                            self.bounds[1],
                                            glyphs_dict=self.glyphs,
                                            attributes=self.attributes,
                                            name = self.feature_name,
                                            feature_height = self.feature_height,
                                            )
        
    def _get_sequence(self):
        """Looks for the sequence matching the seq_id, and applies the bounds to the sequence"""
        if self.genome_path!=None: 
            rec_found=False
            for rec in SeqIO.parse(self.genome_path, 'fasta'):
                if rec.id==self.seq_id:
                    rec_found=True
                    break

            if not rec_found:
                warnings.warn("seq_id not found in fasta file")
            
            self.rec=rec
            self.seq_len = len(self.rec.seq) #length of the reference sequence before bounds are applied
            if self.bounds:
                self.rec.seq=self.rec.seq[self.bounds[0]:self.bounds[1]]    
        else: 
            self.seq_len = self.features.right.max()
    
    def _get_gene_track(self):
        self._set_init_pos()
        if self.init_win>self.max_interval:
            warnings.warn("You requested an initial window larger than max_interval. Change max_interval to plot a larger window (this might overload your memory)")
        self.init_win = min(min(self.init_win,self.bounds[1]-self.bounds[0]),self.max_interval)

        self.tracks=[]
        semi_win = self.init_win / 2
            
        self.x_range = Range1d(
            max(self.bounds[0],self.init_pos - semi_win), min(self.bounds[1],self.init_pos + semi_win), 
            bounds=self.bounds, 
            max_interval=self.max_interval,
            min_interval=30
        )

        self.gene_track = figure(
            tools = "xwheel_zoom, xpan, save, reset",
            active_scroll = "xwheel_zoom",
            height = self.height,
            x_range = self.x_range,
            y_range = Range1d(0, 1),
            output_backend=self.output_backend,
            **self.kwargs
        )
        # Add tool
        self.gene_track.add_tools(BoxZoomTool(dimensions="width"))

        # Format x axis values
        self.gene_track.xaxis[0].formatter = NumeralTickFormatter(format="0,0")
        # Hide grid
        self.gene_track.xgrid.visible = False
        self.gene_track.ygrid.visible = False
        # Hide axis
        self.gene_track.yaxis.visible = False

        self.gene_track.frame_width=self.frame_width
        self.x_range=self.gene_track.x_range
    
    def _set_init_pos(self):
        if self.init_pos == None:
            self.init_pos=sum(self.bounds)//2
        elif self.init_pos>self.bounds[1] or self.init_pos<self.bounds[0]:
            warnings.warn("Requested an initial position outside of the browser bounds")
            self.init_pos=sum(self.bounds)//2
    

# %% ../nbs/API/00_browser.ipynb 12
@patch
def _add_annotations(self:GenomeBrowser):
    #Filter initial glyphs by position
    feature_patches = self.patches.loc[(
        self.patches['xs'].apply(
            lambda x: max(x)>self.x_range.start-self.max_glyph_loading_range)) & (
        self.patches['xs'].apply(
            lambda x: min(x)<self.x_range.end+self.max_glyph_loading_range)
        )]
    
    self._glyph_source = ColumnDataSource(feature_patches.to_dict(orient="list"))
    
    #Information about the range currently plotted
    self._loaded_range = ColumnDataSource({"start":[self.x_range.start-self.max_glyph_loading_range],
                                            "end":[self.x_range.end+self.max_glyph_loading_range], 
                                            "range":[self.max_glyph_loading_range]})
    
    glyph_renderer = self.gene_track.add_glyph(
        self._glyph_source, Patches(xs="xs", ys="ys", fill_color="color", fill_alpha="alpha")
    )
    # gene labels in the annotation track
    # This seems to be necessary to show the labels
    self.gene_track.scatter(x="pos", y=0, size=0, source=self._glyph_source)

    labels = LabelSet(
        x="pos",
        y=self.feature_height+0.07,
        text="names",
        level="glyph",
        x_offset=-5,
        y_offset=0,
        source=self._glyph_source,
        text_align='left',
        text_font_size=self.label_font_size,
        angle=self.label_angle,
    )

    self.gene_track.add_layout(labels)
    tooltips=[(attr,f"@{attr}") for attr in self.attributes]
    self.gene_track.add_tools(
        HoverTool(
            renderers=[glyph_renderer],
            tooltips=tooltips,
        )
    )

# %% ../nbs/API/00_browser.ipynb 14
@patch
def _get_sequence_div(self:GenomeBrowser):
        ## Setting the div that will display the sequence
        sty=Styles(font_size='14px',
                font_family="Courrier",
                color="black",
                display="inline-block",
                overflow="hidden",
                background_color = "white",
                margin="0",
                margin_left= "2px",
                )
        
        self._div = Div(height=18, height_policy="fixed", 
                        width=self.frame_width, 
                        max_width=self.frame_width,
                        width_policy="fixed",
                        styles = sty,
                        )

# %% ../nbs/API/00_browser.ipynb 16
@patch
def _set_js_callbacks(self:GenomeBrowser):
        ## Adding the ability to display the sequence when zooming in
        self.sequence_dic = {
            'seq': str(self.rec.seq).upper() if self.show_seq else "",
            'bounds':self.bounds,
        }

        self._xcb = CustomJS(
            args={
                "x_range": self.gene_track.x_range,
                "sequence": self.sequence_dic,
                "all_glyphs":self.patches.to_dict(orient="list"),
                "glyph_source": self._glyph_source,
                "div": self._div,
                "loaded_range":self._loaded_range,
            },
            code=x_range_change_callback_code
        )
        
        self._glyph_update_callback = CustomJS(
            args={
                "x_range": self.gene_track.x_range,
                "all_glyphs":self.patches.to_dict(orient="list"),
                "glyph_source": self._glyph_source,
                "loaded_range":self._loaded_range,
            },
            code=glyph_update_callback_code
        )

        self.gene_track.x_range.js_on_change('start', self._xcb, self._glyph_update_callback)

# %% ../nbs/API/00_browser.ipynb 18
@patch
def _get_browser_elements(self:GenomeBrowser):
        self._add_annotations()
        self._get_sequence_div()
        self._set_js_callbacks()

        if self.show_seq:
            self.elements = [self.gene_track,self._div]
        else:
            self.elements = [self.gene_track]

# %% ../nbs/API/00_browser.ipynb 20
@patch
def _get_sequence_search(self:GenomeBrowser):
        seq_input = TextInput(placeholder="search by sequence")

        ## Adding BoxAnnotation to highlight search results
        search_span_source = ColumnDataSource({"x":[],"width":[],"fill_color":[]})#"y":[]
        h=Rect(x='x',y=0,
               width='width',
               height=self.gene_track.height,
               fill_color='fill_color',
               line_color="fill_color",
               fill_alpha=0.2,
               line_alpha=0.4)
        
        self.gene_track.add_glyph(search_span_source, h)

        call_back_sequence_search = CustomJS(
            args={
                "x_range": self.x_range,
                "sequence": self.sequence_dic,
                "bounds": self.bounds,
                "search_span_source": search_span_source,
            },
            code=sequence_search_code
        )

        seq_input.js_on_change('value',call_back_sequence_search, self._xcb, self._glyph_update_callback)
        
        sty=Styles(
                   margin_left="1px",
                   margin_right="1px",
                   border = "none",
                   #width = "10px",
                )
        
        nextButton = Button(icon=TablerIcon("arrow-right"),
                            label="",
                            #button_type="primary",
                            styles = sty)
        
        nextButton_callback = CustomJS(
            args={
                "x_range": self.x_range,
                "bounds": self.bounds,
                "search_span_source": search_span_source,
            },
            code=next_button_code)
        
        nextButton.js_on_event("button_click", nextButton_callback, self._xcb, self._glyph_update_callback)
        
        previousButton = Button(icon=TablerIcon("arrow-left"),
                                label="",
                                styles = sty,
                                #button_type="primary"
                               )
        
        previousButton_callback = CustomJS(
            args={
                "x_range": self.x_range,
                "bounds": self.bounds,
                "search_span_source": search_span_source,
            },
            code=previous_button_code)
        
        previousButton.js_on_event("button_click", previousButton_callback, self._xcb, self._glyph_update_callback)

        return row(seq_input, previousButton, nextButton)

# %% ../nbs/API/00_browser.ipynb 22
@patch
def _get_search_box(self:GenomeBrowser):
        ## Create a text input widget for search
        completions=set()
        #for attr in self.patches.columns:
        #    if not attr in ["xs","ys","color","pos"]:
        #        completions.update(map(str,set(self.patches[attr])))
        completions.update(map(str,set(self.patches["names"])))
        
        search_input = AutocompleteInput(completions=list(completions), placeholder="search by name")
        #search_input = TextInput()
        
        call_back_search = CustomJS(
            args={
                "x_range": self.x_range,
                "glyph_source": self._glyph_source,
                "bounds": self.bounds,
                "all_glyphs": self.patches.to_dict(orient="list"),
                "loaded_range": self._loaded_range,
                "div": self._div,
            },
            code=search_callback_code
        )

        search_input.js_on_change('value', call_back_search, self._xcb, self._glyph_update_callback)

        return search_input
    
    

# %% ../nbs/API/00_browser.ipynb 24
@patch
def show(self:GenomeBrowser):
        if len(self.features)>0:
            self._get_browser_elements() 
            if self.search:
                search_elements = [self._get_search_box()]
                if self.show_seq:
                     search_elements.append(self._get_sequence_search())
                self.elements = [row(search_elements)]+self.elements

            bk_show(column(self.elements + [t.fig for t in self.tracks]))

# %% ../nbs/API/00_browser.ipynb 41
from .track import Track

# %% ../nbs/API/00_browser.ipynb 42
@patch
def add_track(self: GenomeBrowser,
             height: int = 200, #size of the track
             tools: str = "xwheel_zoom, ywheel_zoom, pan, box_zoom, save, reset", #comma separated list of Bokeh tools that can be used to navigate the plot
             **kwargs,
             ) -> Track:
    """Adds a track to the GenomeBrowser. Ensures that the x_range are shared and figure widths are identical."""
    t = Track(height=height, 
              output_backend=self.output_backend,
              tools=tools,
              **kwargs)
    t.fig.x_range = self.x_range
    t.fig.frame_width = self.frame_width
    t.bounds = self.bounds
    t.loaded_range = ColumnDataSource({"start":[self.x_range.start-self.max_glyph_loading_range],
                                        "end":[self.x_range.end+self.max_glyph_loading_range], 
                                        "range":[self.max_glyph_loading_range]})
    t.max_glyph_loading_range = self.max_glyph_loading_range
    self.tracks.append(t)
    return t
    

# %% ../nbs/API/00_browser.ipynb 44
@patch
def highlight(self:GenomeBrowser,
         data: pd.DataFrame, #pandas DataFrame containing the data
         left: str = "left", #name of the column containing the start positions of the regions
         right: str = "right", #name of the column containing the end positions of the regions
         color: str = "color", #color of the regions
         alpha: str = 0.2, #transparency
         hover_data: list = [], #list of additional column names to be shown when hovering over the data
         highlight_tracks: bool = False, #whether to highlight just the annotation track or also the other tracks
         **kwargs, #enables to pass keyword arguments used by the Bokeh function
        ):
    
    if type(hover_data)==str:
        hover_data = [hover_data]

    if color not in data.columns:
        data["color"]='green'

    data["alpha"]=alpha

    highlight_source = ColumnDataSource(data[[left,right,"color","alpha"]+hover_data])

    r=Quad(left=left, right=right,
           bottom=0,
           top=1,
           fill_color="color",
           fill_alpha="alpha",
           line_alpha=0,
           **kwargs)

    renderer= self.gene_track.add_glyph(highlight_source, r)
    tooltips=[(f"{left} - {right}",f"@{left} - @{right}")]+[(f"{attr}",f"@{attr}") for attr in hover_data]
    self.gene_track.add_tools(HoverTool(renderers=[renderer],
                                        tooltips=tooltips))
    
    if highlight_tracks:
        for t in self.tracks:
            t.highlight(data=data,left=left,right=right,color=color,alpha=alpha,hover_data=hover_data,**kwargs)

# %% ../nbs/API/00_browser.ipynb 48
from bokeh.io import export_svgs, export_svg, export_png
from selenium.webdriver.chrome.service import Service
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
import os
from svgutils import compose

# %% ../nbs/API/00_browser.ipynb 49
@patch
def save(self:GenomeBrowser, 
         fname: str, #path to file or a simple name (extensions are automatically added)
        ):
        """This function saves the initial plot that is generated and not the current view of the browser.
        To save in svg format you must initialise your GenomeBrowser using `output_backend="svg"` """
        if len(self.features)>0:
            self._get_browser_elements()
            layout=column(self.elements + [t.fig for t in self.tracks])

        if in_wsl():
                ## Setup chrome options
                chrome_options = Options()
                chrome_options.add_argument("--headless") # Ensure GUI is off
                chrome_options.add_argument("--no-sandbox")
                chrome_options.add_argument("--disable-3d-apis")
                chrome_options.add_argument("--disable-blink-features")
                

                homedir = os.path.expanduser("~")
                try:
                        webdriver_service = Service(f"{homedir}/chromedriver/stable/chromedriver")
                        browser = webdriver.Chrome(service=webdriver_service, options=chrome_options)
                except:
                        warnings.warn("If using WSL you can install chromedriver following these instructions: https://cloudbytes.dev/snippets/run-selenium-and-chrome-on-wsl2 \n\
                                Keep the path to chromdriver as in these instructions: ~/chromedriver/stable/chromedriver")
                        browser=None

                
        else:
                browser=None

        base_name, ext = os.path.splitext(fname)
        if self.output_backend=="svg":
                fname=add_extension(fname,extension="svg")
                export_svgs(layout, filename=fname, webdriver=browser)
                if len(self.tracks)>0:
                    total_height=sum([self.height]+[t.height for t in self.tracks])
                    svgelements=[compose.SVG(fname)]
                    offset=self.height
                    for i,t in enumerate(self.tracks):
                        svgelements.append(
                            compose.SVG(f"{base_name}_{i+1}.svg").move(0,offset)
                        )
                        offset+=t.height
                        
                    compose.Figure(self.frame_width+50, # +50 accounts for axis and labels
                                   total_height, 
                                   *svgelements).save(f"{base_name}_composite.svg")

        elif self.output_backend=="webgl":
                if ext.lower()==".svg":
                        warnings.warn('In order to save to svg you need to set the option output_backend="svg" when calling GenomeBrowser')

                fname=add_extension(fname,extension="png")
                export_png(layout, filename=fname, webdriver=browser)
