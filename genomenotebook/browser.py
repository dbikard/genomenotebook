# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_browser.ipynb.

# %% auto 0
__all__ = ['GenomeBrowser', 'Track']

# %% ../nbs/01_browser.ipynb 4
from fastcore.basics import *

from genomenotebook.utils import (
    get_genome_annotations,
    get_gene_patches, 
    get_genes_from_annotation, 
    create_genome_browser_plot,
    get_all_glyphs)
from bokeh.models import (
    CustomJS,
    Range1d,
    ColumnDataSource,
    LabelSet, 
    TextInput,
    Rect,
    Div,
    Styles,
    NumeralTickFormatter
)
from bokeh.plotting import show, figure
from bokeh.layouts import column, row

from Bio import SeqIO
from .js_callback_code import x_range_change_callback_code, search_callback_code, get_example_data_dir
from bokeh.io import output_notebook
import numpy as np
import pandas as pd
import os
import itertools

try: #pyBigWig cannot be installed on Windows. This might make it possible for windows users to still install
    import pyBigWig
except ImportError:
    pyBigWig = None
    
import warnings

# %% ../nbs/01_browser.ipynb 6
class GenomeBrowser:
    def __init__(self,
                 genome_path: str, #path to the fasta file of the genome sequence
                 gff_path: str, #path to the gff3 file of the annotations
                 seq_id: str = None, #id of the sequence to show for genomes with multiple contigs
                 init_pos: int = None, #initial position to display
                 init_win: int = 10000, #initial window size (max=20000)
                 bounds: tuple = None, #bounds can be specified. This helps preserve memory by not loading the whole genome if not needed.
                 show_seq: bool = True, #shows the sequence when zooming in
                 search: bool = True, #enables a search bar to lookup a gene name or a DNA sequence
                 **kwargs):
        
        self.genome_path = genome_path
        self.gff_path = gff_path
        self.rec = self.get_sequence_record(seq_id)            
        self.seq_len = len(self.rec.seq) #length of the reference sequence before bounds are applied
        self.apply_bounds(bounds)
        self.set_init_pos(init_pos)

        self.init_win = min(init_win,self.bounds[1]-self.bounds[0])

        self.show_seq = show_seq
        self.max_glyph_loading_range = 20000
        self.frame_width = 600

        self.elements = self.get_browser(show_seq=show_seq)
        self.activate_search(search)
        self.tracks=[]

    def activate_search(self,search):
        if search:
            self.search = self.get_search_box()
            self.elements = [self.search]+self.elements
        else:
            self.search = None
    
    def set_init_pos(self, init_pos):
        if init_pos == None:
            self.init_pos=sum(self.bounds)//2
        elif init_pos>self.bounds[1] or init_pos<self.bounds[0]:
            warnings.warn("Requested an initial position outside of the browser bounds")
            self.init_pos=sum(self.bounds)//2
        else:
            self.init_pos=init_pos
    
    def apply_bounds(self, bounds):
        if bounds == None:
            self.bounds=(0,self.seq_len)
        else:
            self.bounds=bounds
        
        self.rec.seq=self.rec.seq[self.bounds[0]:self.bounds[1]]

    def get_sequence_record(self, seq_id):
        if seq_id==None: #when no seq_id is provided we take the first element
            rec = next(SeqIO.parse(self.genome_path, 'fasta'))
        else:
            rec_found=False
            for rec in SeqIO.parse(self.genome_path, 'fasta'):
                if rec.id==seq_id:
                    rec_found=True
                    break
            
            if not rec_found:
                warnings.warn("seq_id not found in fasta file")
        return rec

    def get_browser(self,show_seq=True):

        semi_win = self.init_win / 2
        x_range = Range1d(
            max(self.bounds[0],self.init_pos - semi_win), min(self.bounds[1],self.init_pos + semi_win), 
            bounds=self.bounds, 
            max_interval=100000,
            min_interval=40
        )
        
        annotation = get_genome_annotations(self.gff_path,
                                            seq_id = self.rec.id,
                                            bounds = self.bounds)
        
        genes = get_genes_from_annotation(annotation) 
        
        #This contains the glyphs plotted by bokeh
        self.glyph_source = ColumnDataSource(get_gene_patches(genes, x_range.start, x_range.end))

        #This contains the positions of the glyphs plotted by bokeh
        loaded_glyph_source = ColumnDataSource({"start":[x_range.start],"end":[x_range.end], "range":[self.max_glyph_loading_range]})

        #This contains the glyphs for the whole genome
        self.all_glyphs=get_all_glyphs(genes, self.bounds)

        p = create_genome_browser_plot(self.glyph_source, x_range, output_backend="webgl")
        p.frame_width=self.frame_width

        sty=Styles(font_size='14px',
                font_family="Courrier",
                color="black",
                display="inline-block",
                background_color = "white",
                margin="0",
                margin_left= "2px",
                )
        
        ## Adding the ability to display the sequence when zooming in
        sequence = {
            'seq': str(self.rec.seq).upper(),
            'bounds':self.bounds
        }

        self.div = Div(height=18, height_policy="fixed", 
                    width=600, width_policy="fixed",
                    styles = sty
                    )

        xcb = CustomJS(
            args={
                "x_range": p.x_range,
                "sequence": sequence,
                "all_glyphs":self.all_glyphs,
                "glyph_source": self.glyph_source,
                "div": self.div,
                "loaded_glyph_source":loaded_glyph_source,
            },
            code=x_range_change_callback_code
        )

        p.x_range.js_on_change('start', xcb)
        self.x_range=p.x_range
        self.gene_track=p

        if self.show_seq:
            return [p,self.div]
        else:
            return [p]

    def get_search_box(self):

        ## Create a text input widget for search
        text_input = TextInput(value="")

        ## Adding BoxAnnotation to highlight search results
        search_span_source = ColumnDataSource({"x":[],"width":[]})#"y":[]
        h=Rect(x='x',y=-2,width='width',height=self.gene_track.height,fill_color='green',fill_alpha=0.2,line_alpha=0)
        self.gene_track.add_glyph(search_span_source, h)

        ## Adding the ability to display the sequence when zooming in
        sequence = {
            'seq': str(self.rec.seq).upper(),
            'bounds':self.bounds
        }

        call_back_search = CustomJS(
            args={
                "x_range": self.x_range,
                "glyph_source": self.glyph_source,
                "sequence": sequence,
                "all_glyphs": self.all_glyphs,
                "text_input": text_input,
                "search_span_source": search_span_source,
                "div": self.div,
            },
            code=search_callback_code
        )

        text_input.js_on_change('value',call_back_search)#,xcb)

        return text_input
    
    def show(self):
        show(column(self.elements + [t.fig for t in self.tracks]))



# %% ../nbs/01_browser.ipynb 12
class Track:
    def __init__(self,
                 height: int = 200, #size of the track
                ):
        self.height = height
        self.fig = figure(tools="xwheel_zoom,xpan,save,reset",
                          active_scroll="xwheel_zoom",
                          height=height,
                          y_axis_location="right", #this is required in order to keep a proper alignment with the sequence
                          output_backend="webgl")
        self.fig.xaxis[0].formatter = NumeralTickFormatter(format="0,0")
        


# %% ../nbs/01_browser.ipynb 14
@patch
def add_track(self:GenomeBrowser,
             height:int = 200 #size of the track
             ) -> Track:
    """Adds a track to the the GenomeBrowser. Ensures that the x_range are shared and figure widths are identical."""
    t = Track(height=height)
    t.fig.x_range = self.x_range
    t.fig.frame_width = self.frame_width
    t.bounds = self.bounds
    self.tracks.append(t)
    return t
    

# %% ../nbs/01_browser.ipynb 17
@patch
def filter_source(self:Track,
                  source,
                  pos):
    source=source.loc[(self.bounds[0] < source[pos]) & (source[pos] < self.bounds[1])]
    if len(source)>10**5:
        warnings.warn("You are trying to plot more than 10^5 glyphs, this might crash your memory. \
        Consider using bounds or reducing the number of datapoints.")
    return source

# %% ../nbs/01_browser.ipynb 18
@patch
def line(self:Track,
         source: pd.DataFrame, #pandas DataFrame containing the data
         pos: str, #name of the column containing the positions along the genome
         y: str, #name of the column containing the data to be plotted on the y-axis
         **kwargs #enables to pass keyword arguments used by the Bokeh function
        ):
    source=self.filter_source(source, pos)
    
    self.fig.line(source=source, x=pos, y=y, **kwargs)


# %% ../nbs/01_browser.ipynb 21
from bokeh.transform import factor_cmap

# %% ../nbs/01_browser.ipynb 22
@patch
def scatter(self:Track,
         source: pd.DataFrame, #pandas DataFrame containing the data
         pos: str, #name of the column containing the positions along the genome
         y: str, #name of the column containing the data to be plotted on the y-axis
         factors: str = None, #name of a column of values to be used as factors
         **kwargs, #enables to pass keyword arguments used by the Bokeh function
        ):
    source=self.filter_source(source, pos)
    
    if factors!=None:
        color=factor_cmap(factors,"Category10_3",tuple(set(source[factors].values)))
        
        self.fig.scatter(source=source, x=pos, y=y, color=color, legend_group=factors, **kwargs)

        self.fig.legend.location = "top_left"
        self.fig.legend.title = "ori"
    else:
        self.fig.scatter(source=source, x=pos, y=y, **kwargs)


# %% ../nbs/01_browser.ipynb 26
@patch
def bar(self:Track,
         source: pd.DataFrame, #pandas DataFrame containing the data
         pos: str, #name of the column containing the positions along the genome
         y: str, #name of the column containing the data to be plotted on the y-axis
         z: str = None, #name of a column containing numerical data rendered as a linear color map (cannot be used for line plots)
         factors: str = None, #name of a column of values to be used as factors
         **kwargs, #enables to pass keyword arguments used by the Bokeh function
        ):
    source=self.filter_source(source, pos)
    
    if factors!=None:
        color=factor_cmap(factors,"Category10_3",tuple(set(source[factors].values)))
        
        self.fig.vbar(source=source, x=pos, top=y, color=color, legend_group=factors, **kwargs)

        self.fig.legend.location = "top_left"
        self.fig.legend.title = "ori"
    elif z!=None:
        pass
    else:
        self.fig.vbar(source=source, x=pos, top=y, **kwargs)
        
