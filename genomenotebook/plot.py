"""This contains the plotting and saving logic"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/API/03_plot.ipynb.

# %% auto 0
__all__ = ['GenomePlot']

# %% ../nbs/API/03_plot.ipynb 4
from fastcore.basics import *

from typing import Union, List, Dict, Optional
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from genomenotebook.browser import GenomeBrowser
    
from genomenotebook.javascript import (
    x_range_change_callback_code,
    glyph_update_callback_code,
    search_callback_code,
    sequence_search_code,
    next_button_code,
    previous_button_code
)

from .utils import in_wsl

from bokeh.plotting import figure
from bokeh.models.tools import BoxZoomTool
from bokeh.models.glyphs import Patches
from bokeh.models import (
    CustomJS,
    Range1d,
    ColumnDataSource,
    AutocompleteInput,
    TextInput,
    Button,
    Rect,
    Div,
    Styles,
    TablerIcon,
    HoverTool, 
    NumeralTickFormatter, 
    LabelSet,
    HoverTool,
    TapTool,
    Quad
)

from bokeh.plotting import show as bk_show
from bokeh.layouts import column, row
from bokeh.io import output_notebook, reset_output, export_png, export_svgs, export_svg
from bokeh.plotting import save as bk_save #Need to rename the bokeh show function so that there is no confusion with GenomeBrowser.show
from bokeh.plotting import output_file as bk_output_file #Need to rename the bokeh show function so that there is no confusion with GenomeBrowser.show

from svgutils import compose
import os
import warnings
from selenium.webdriver.chrome.options import Options
from selenium import webdriver


# %% ../nbs/API/03_plot.ipynb 7
class GenomePlot():
    def __init__(self, browsers:Union["GenomeBrowser",List["GenomeBrowser"]], #a GenomeBrowser object or list of GenomeBrowser objects when a GenomeStack is rendered
                 output_backend:str="webgl" # can be "webgl" or "svg". webgl is more efficient but svg is a vectorial format that can be conveniently modified using other software
                ):
        '''A GenomePlot object is created to handle all the rendering logic of GenomeBrowser objects'''

        if isinstance(browsers, list):
            self.browser = browsers[0]
            if len(browsers) > 1:
                self.child_browsers = browsers[1:]
        else:
            self.browser = browsers
            self.child_browsers = []


        self.output_backend = output_backend
        self.elements = []
        self.tracks = []
        self.track_figs = []
        
        self._get_main_fig()
        self.elements = self._collect_elements()
        
        for track in self.browser.tracks:
            self._add_track(track)

        for modifier in self.browser.modifiers:
            if modifier.gene_track:
                modifier.render(self.main_fig)
            if modifier.data_tracks:
                for i, track in enumerate(self.tracks):
                    modifier.render(self.track_figs[i], True, track.__dict__)
            
        
        for browser in self.child_browsers:
            pass # TODO: merge in GenomeStack.show()

    def _add_track(self, track):
        fig = track.get_fig(
                x_range=self.x_range, 
                width=self.browser.width, 
                bounds=self.browser.bounds,
                max_glyph_loading_range=self.browser.max_glyph_loading_range,
                output_backend=self.output_backend
            )
        self.elements.append(fig)
        self.track_figs.append(fig)
        self.tracks.append(track)
        
    def _get_main_fig(self):
        self._set_init_pos()
        if self.browser.init_win>self.browser.max_interval:
            warnings.warn("You requested an initial window larger than max_interval. Change max_interval to plot a larger window (this might overload your memory)")
        self.init_win = min(min(self.browser.init_win,self.browser.bounds[1]-self.browser.bounds[0]),self.browser.max_interval)

        semi_win = self.init_win / 2
            
        self.x_range = Range1d(
            max(self.browser.bounds[0],self.init_pos - semi_win), min(self.browser.bounds[1],self.init_pos + semi_win), 
            bounds=self.browser.bounds, 
            max_interval=self.browser.max_interval,
            min_interval=30
        )

        self.main_fig = figure(
            tools = "xwheel_zoom, xpan, save, reset",
            active_scroll = "xwheel_zoom",
            height = self.browser.height,
            x_range = self.x_range,
            y_range = Range1d(0, 1),
            output_backend=self.output_backend,
            **self.browser.kwargs
        )
        # Add tool
        self.main_fig.add_tools(BoxZoomTool(dimensions="width"))

        # Format x axis values
        self.main_fig.xaxis[0].formatter = NumeralTickFormatter(format="0,0")
        # Hide grid
        self.main_fig.xgrid.visible = False
        self.main_fig.ygrid.visible = False
        # Hide axis
        self.main_fig.yaxis.visible = False

        self.main_fig.frame_width=self.browser.width
        
        self.x_range
    
    def _set_init_pos(self):
        self.init_pos = self.browser.init_pos
        if self.init_pos == None:
            self.init_pos = sum(self.browser.bounds)//2
        elif self.init_pos > self.browser.bounds[1] or self.init_pos < self.browser.bounds[0]:
            warnings.warn("Requested an initial position outside of the browser bounds")
            self.init_pos = sum(self.browser.bounds)//2

# %% ../nbs/API/03_plot.ipynb 9
@patch
def _collect_elements(self:GenomePlot):
    self._get_browser_elements()
    elements = self.elements.copy()
    if self.browser.search:
        search_elements = [self._get_search_box()]
        if self.browser.show_seq:
             search_elements.append(self._get_sequence_search())
        elements = [row(search_elements)]+elements

    return elements

# %% ../nbs/API/03_plot.ipynb 10
@patch
def _add_annotations(self:GenomePlot):
    """
    Creates the Bokeh ColumnDataSource objects for the glyphs and add the glyphs and labels to the main_fig
    """
    
    #Filter initial glyphs by position
    feature_patches = self.browser.patches.loc[(
        self.browser.patches['xs'].apply(
            lambda x: max(x)>self.x_range.start-self.browser.max_glyph_loading_range)) & (
        self.browser.patches['xs'].apply(
            lambda x: min(x)<self.x_range.end+self.browser.max_glyph_loading_range)
        )].copy()
    
    self._glyph_source = ColumnDataSource(feature_patches.to_dict(orient="list"))
    
    #Information about the range currently plotted
    self._loaded_range = ColumnDataSource({"start":[self.x_range.start-self.browser.max_glyph_loading_range],
                                            "end":[self.x_range.end+self.browser.max_glyph_loading_range], 
                                            "range":[self.browser.max_glyph_loading_range]})
    
    glyph_renderer = self.main_fig.add_glyph(
        self._glyph_source, Patches(xs="xs", ys="ys", fill_color="color", fill_alpha="alpha")
    )
    # gene labels in the annotation track
    # This seems to be necessary to show the labels
    #self.main_fig.scatter(x="label_x", y=0, size=0, source=self._glyph_source)
    
    #ys = list()
    
    if self.browser.show_labels:
        labels = LabelSet(
            x="label_x",
            y="label_y",
            text="names",
            level="glyph",
            x_offset=self.browser.label_horizontal_offset,
            y_offset=0,
            source=self._glyph_source,
            text_align='left',
            text_font_size=self.browser.label_font_size,
            angle=self.browser.label_angle,
        )

        self.main_fig.add_layout(labels)
    self.main_fig.add_tools(
        HoverTool(
            renderers=[glyph_renderer],
            tooltips="<div>@attributes</div>",
        )
    )

# %% ../nbs/API/03_plot.ipynb 11
@patch
def _get_sequence_div(self:GenomePlot):
        ## Setting the div that will display the sequence
        sty=Styles(font_size='14px',
                font_family="Courrier",
                color="black",
                display="inline-block",
                overflow="hidden",
                background_color = "white",
                margin="0",
                margin_left= "2px",
                )
        
        self._div = Div(height=18, height_policy="fixed", 
                        width=self.browser.width, 
                        max_width=self.browser.width,
                        width_policy="fixed",
                        styles = sty,
                        )

# %% ../nbs/API/03_plot.ipynb 12
@patch
def _set_js_callbacks(self:GenomePlot):
        ## Adding the ability to display the sequence when zooming in
        self.sequence_dic = {
            'seq': str(self.browser.seq).upper() if self.browser.show_seq else "",
            'bounds':self.browser.bounds,
        }

        self._xcb = CustomJS(
            args={
                "x_range": self.main_fig.x_range,
                "sequence": self.sequence_dic,
                "all_glyphs":self.browser.patches.to_dict(orient="list"),
                "glyph_source": self._glyph_source,
                "div": self._div,
                "loaded_range":self._loaded_range,
            },
            code=x_range_change_callback_code
        )
        
        self._glyph_update_callback = CustomJS(
            args={
                "x_range": self.main_fig.x_range,
                "all_glyphs":self.browser.patches.to_dict(orient="list"),
                "glyph_source": self._glyph_source,
                "loaded_range":self._loaded_range,
            },
            code=glyph_update_callback_code
        )

        self.main_fig.x_range.js_on_change('start', self._xcb, self._glyph_update_callback)

# %% ../nbs/API/03_plot.ipynb 13
@patch
def _get_search_box(self:GenomePlot):
        ## Create a text input widget for search
        completions=set()
        #for attr in self.patches.columns:
        #    if not attr in ["xs","ys","color","pos"]:
        #        completions.update(map(str,set(self.patches[attr])))
        completions.update(map(str,set(self.browser.patches["names"])))
        
        search_input = AutocompleteInput(completions=list(completions), placeholder="search by name")
        #search_input = TextInput()
        
        call_back_search = CustomJS(
            args={
                "x_range": self.x_range,
                "glyph_source": self._glyph_source,
                "bounds": self.browser.bounds,
                "all_glyphs": self.browser.patches.to_dict(orient="list"),
                "loaded_range": self._loaded_range,
                "div": self._div,
            },
            code=search_callback_code
        )

        search_input.js_on_change('value', call_back_search, self._xcb, self._glyph_update_callback)

        return search_input
    
    

# %% ../nbs/API/03_plot.ipynb 14
@patch
def _get_browser_elements(self:GenomePlot):
        self._add_annotations() 
        self._get_sequence_div()
        self._set_js_callbacks()

        if self.browser.show_seq:
            self.elements = [self.main_fig,self._div]
        else:
            self.elements = [self.main_fig]

# %% ../nbs/API/03_plot.ipynb 15
@patch
def _get_sequence_search(self:GenomePlot):
        seq_input = TextInput(placeholder="search by sequence")

        ## Adding BoxAnnotation to highlight search results
        search_span_source = ColumnDataSource({"x":[],"width":[],"fill_color":[]})#"y":[]
        h=Rect(x='x',y=0,
               width='width',
               height=self.main_fig.height,
               fill_color='fill_color',
               line_color="fill_color",
               fill_alpha=0.2,
               line_alpha=0.4)
        
        self.main_fig.add_glyph(search_span_source, h)

        call_back_sequence_search = CustomJS(
            args={
                "x_range": self.x_range,
                "sequence": self.sequence_dic,
                "bounds": self.browser.bounds,
                "search_span_source": search_span_source,
            },
            code=sequence_search_code
        )

        seq_input.js_on_change('value',call_back_sequence_search, self._xcb, self._glyph_update_callback)
        
        sty=Styles(
                   margin_left="1px",
                   margin_right="1px",
                   border = "none",
                   #width = "10px",
                )
        
        nextButton = Button(icon=TablerIcon("arrow-right"),
                            label="",
                            #button_type="primary",
                            styles = sty)
        
        nextButton_callback = CustomJS(
            args={
                "x_range": self.x_range,
                "bounds": self.browser.bounds,
                "search_span_source": search_span_source,
            },
            code=next_button_code)
        
        nextButton.js_on_event("button_click", nextButton_callback, self._xcb, self._glyph_update_callback)
        
        previousButton = Button(icon=TablerIcon("arrow-left"),
                                label="",
                                styles = sty,
                                #button_type="primary"
                               )
        
        previousButton_callback = CustomJS(
            args={
                "x_range": self.x_range,
                "bounds": self.browser.bounds,
                "search_span_source": search_span_source,
            },
            code=previous_button_code)
        
        previousButton.js_on_event("button_click", previousButton_callback, self._xcb, self._glyph_update_callback)

        return row(seq_input, previousButton, nextButton)

# %% ../nbs/API/03_plot.ipynb 17
@patch
def _get_search_box(self:GenomePlot):
        ## Create a text input widget for search
        completions=set()
        #for attr in self.patches.columns:
        #    if not attr in ["xs","ys","color","pos"]:
        #        completions.update(map(str,set(self.patches[attr])))
        completions.update(map(str,set(self.browser.patches["names"])))
        
        search_input = AutocompleteInput(completions=list(completions), placeholder="search by name")
        #search_input = TextInput()
        
        call_back_search = CustomJS(
            args={
                "x_range": self.x_range,
                "glyph_source": self._glyph_source,
                "bounds": self.browser.bounds,
                "all_glyphs": self.browser.patches.to_dict(orient="list"),
                "loaded_range": self._loaded_range,
                "div": self._div,
            },
            code=search_callback_code
        )

        search_input.js_on_change('value', call_back_search, self._xcb, self._glyph_update_callback)

        return search_input

# %% ../nbs/API/03_plot.ipynb 20
@patch
def _collect_elements(self:GenomePlot):
    self._get_browser_elements()
    elements = self.elements.copy()
    if self.browser.search:
        search_elements = [self._get_search_box()]
        if self.browser.show_seq:
             search_elements.append(self._get_sequence_search())
        elements = [row(search_elements)]+elements

    return elements

# %% ../nbs/API/03_plot.ipynb 21
@patch
def _add_annotations(self:GenomePlot):
    """
    Creates the Bokeh ColumnDataSource objects for the glyphs and add the glyphs and labels to the main_fig
    """
    
    #Filter initial glyphs by position
    feature_patches = self.browser.patches.loc[(
        self.browser.patches['xs'].apply(
            lambda x: max(x)>self.x_range.start-self.browser.max_glyph_loading_range)) & (
        self.browser.patches['xs'].apply(
            lambda x: min(x)<self.x_range.end+self.browser.max_glyph_loading_range)
        )].copy()
    
    self._glyph_source = ColumnDataSource(feature_patches.to_dict(orient="list"))
    
    #Information about the range currently plotted
    self._loaded_range = ColumnDataSource({"start":[self.x_range.start-self.browser.max_glyph_loading_range],
                                            "end":[self.x_range.end+self.browser.max_glyph_loading_range], 
                                            "range":[self.browser.max_glyph_loading_range]})
    
    glyph_renderer = self.main_fig.add_glyph(
        self._glyph_source, Patches(xs="xs", ys="ys", fill_color="color", fill_alpha="alpha")
    )
    # gene labels in the annotation track
    # This seems to be necessary to show the labels
    #self.main_fig.scatter(x="label_x", y=0, size=0, source=self._glyph_source)
    
    #ys = list()
    
    if self.browser.show_labels:
        labels = LabelSet(
            x="label_x",
            y="label_y",
            text="names",
            level="glyph",
            x_offset=self.browser.label_horizontal_offset,
            y_offset=0,
            source=self._glyph_source,
            text_align='left',
            text_font_size=self.browser.label_font_size,
            angle=self.browser.label_angle,
        )

        self.main_fig.add_layout(labels)
    self.main_fig.add_tools(
        HoverTool(
            renderers=[glyph_renderer],
            tooltips="<div>@attributes</div>",
        )
    )

# %% ../nbs/API/03_plot.ipynb 22
@patch
def _set_js_callbacks(self:GenomePlot):
        ## Adding the ability to display the sequence when zooming in
        self.sequence_dic = {
            'seq': str(self.browser.seq).upper() if self.browser.show_seq else "",
            'bounds':self.browser.bounds,
        }

        self._xcb = CustomJS(
            args={
                "x_range": self.main_fig.x_range,
                "sequence": self.sequence_dic,
                "all_glyphs":self.browser.patches.to_dict(orient="list"),
                "glyph_source": self._glyph_source,
                "div": self._div,
                "loaded_range":self._loaded_range,
            },
            code=x_range_change_callback_code
        )
        
        self._glyph_update_callback = CustomJS(
            args={
                "x_range": self.main_fig.x_range,
                "all_glyphs":self.browser.patches.to_dict(orient="list"),
                "glyph_source": self._glyph_source,
                "loaded_range":self._loaded_range,
            },
            code=glyph_update_callback_code
        )

        self.main_fig.x_range.js_on_change('start', self._xcb, self._glyph_update_callback)

# %% ../nbs/API/03_plot.ipynb 23
@patch
def _get_sequence_search(self:GenomePlot):
        seq_input = TextInput(placeholder="search by sequence")

        ## Adding BoxAnnotation to highlight search results
        search_span_source = ColumnDataSource({"x":[],"width":[],"fill_color":[]})#"y":[]
        h=Rect(x='x',y=0,
               width='width',
               height=self.main_fig.height,
               fill_color='fill_color',
               line_color="fill_color",
               fill_alpha=0.2,
               line_alpha=0.4)
        
        self.main_fig.add_glyph(search_span_source, h)

        call_back_sequence_search = CustomJS(
            args={
                "x_range": self.x_range,
                "sequence": self.sequence_dic,
                "bounds": self.browser.bounds,
                "search_span_source": search_span_source,
            },
            code=sequence_search_code
        )

        seq_input.js_on_change('value',call_back_sequence_search, self._xcb, self._glyph_update_callback)
        
        sty=Styles(
                   margin_left="1px",
                   margin_right="1px",
                   border = "none",
                   #width = "10px",
                )
        
        nextButton = Button(icon=TablerIcon("arrow-right"),
                            label="",
                            #button_type="primary",
                            styles = sty)
        
        nextButton_callback = CustomJS(
            args={
                "x_range": self.x_range,
                "bounds": self.browser.bounds,
                "search_span_source": search_span_source,
            },
            code=next_button_code)
        
        nextButton.js_on_event("button_click", nextButton_callback, self._xcb, self._glyph_update_callback)
        
        previousButton = Button(icon=TablerIcon("arrow-left"),
                                label="",
                                styles = sty,
                                #button_type="primary"
                               )
        
        previousButton_callback = CustomJS(
            args={
                "x_range": self.x_range,
                "bounds": self.browser.bounds,
                "search_span_source": search_span_source,
            },
            code=previous_button_code)
        
        previousButton.js_on_event("button_click", previousButton_callback, self._xcb, self._glyph_update_callback)

        return row(seq_input, previousButton, nextButton)

# %% ../nbs/API/03_plot.ipynb 24
@patch
def _get_browser_elements(self:GenomePlot):
        self._add_annotations() 
        self._get_sequence_div()
        self._set_js_callbacks()

        if self.browser.show_seq:
            self.elements = [self.main_fig,self._div]
        else:
            self.elements = [self.main_fig]

# %% ../nbs/API/03_plot.ipynb 26
@patch
def _get_sequence_div(self:GenomePlot):
        ## Setting the div that will display the sequence
        sty=Styles(font_size='14px',
                font_family="Courrier",
                color="black",
                display="inline-block",
                overflow="hidden",
                background_color = "white",
                margin="0",
                margin_left= "2px",
                )
        
        self._div = Div(height=18, height_policy="fixed", 
                        width=self.browser.width, 
                        max_width=self.browser.width,
                        width_policy="fixed",
                        styles = sty,
                        )

# %% ../nbs/API/03_plot.ipynb 34
def _save_html(elements, fname:str, title:str):
    reset_output()
    bk_output_file(filename=fname, title=title, mode='inline')
    bk_save(column(elements))
    reset_output()

# %% ../nbs/API/03_plot.ipynb 35
def _gb_show(elements):
    reset_output()
    output_notebook(hide_banner=True)
    bk_show(column(elements))
    reset_output()

# %% ../nbs/API/03_plot.ipynb 36
def _save(elements, heights, width, fname:str, title:str="Genome Plot"):
    base_name, ext = os.path.splitext(fname)
    ext = ext.lower()
    if ext not in {".svg", ".png"}:
        raise ValueError(f"filename must end in svg or png, not {ext}")
    
    reset_output()
    bk_output_file(filename=fname, title=title)
    
    layout = column(elements)

    if in_wsl():
            ## Setup chrome options
            chrome_options = Options()
            chrome_options.add_argument("--headless") # Ensure GUI is off
            chrome_options.add_argument("--no-sandbox")
            chrome_options.add_argument("--disable-3d-apis")
            chrome_options.add_argument("--disable-blink-features")
            

            homedir = os.path.expanduser("~")
            try:
                    # webdriver_service = Service(f"{homedir}/chromedriver/stable/chromedriver")
                    # browser = webdriver.Chrome(service=webdriver_service, options=chrome_options)
                    browser = webdriver.Chrome(options=chrome_options)
            except:
                    warnings.warn("""If using WSL you can install chromedriver following these instructions:https://scottspence.com/posts/use-chrome-in-ubuntu-wsl
                                  Also make sure the chromedriver-binary python package has the same major version number as your chrome install.
                                  Check the chrome version using: google-chrome --version
                                   Then use pip to force install of a web driver with a compatible version, for example:
                                   pip install --force-reinstall -v "chromedriver-binary==121.0.6167.184.0"
                                   """)
                    browser=None

            
    else:
            browser=None

    if ext == ".svg":
        #export_svg(layout, filename=fname)
        export_svgs(layout, filename=fname, webdriver=browser)
        if len(heights)>1: # TODO: what is this?
            total_height=sum(heights)
            svgelements=[compose.SVG(fname)]
            offset=heights[0]
            for i, height in enumerate(heights[1:]):
                svgelements.append(
                    compose.SVG(f"{base_name}_{i+1}.svg").move(0,offset)
                )
                offset+=height
                
            compose.Figure(width+50, # +50 accounts for axis and labels
                           total_height, 
                           *svgelements).save(f"{base_name}_composite.svg")

    else:
        export_png(layout, filename=fname, webdriver=browser)
    
    reset_output()
