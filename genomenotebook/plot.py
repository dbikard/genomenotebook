"""This contains the plotting and saving logic"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/API/03_plot.ipynb.

# %% auto 0
__all__ = ['GenomePlot']

# %% ../nbs/API/03_plot.ipynb 4
from fastcore.basics import *

from typing import Union, List, Dict, Optional
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from genomenotebook.browser import GenomeBrowser
    
from genomenotebook.javascript import (
    x_range_change_callback_code,
    glyph_update_callback_code,
    search_callback_code,
    sequence_search_code,
    next_button_code,
    previous_button_code
)

from bokeh.plotting import figure
from bokeh.models.tools import BoxZoomTool
from bokeh.models.glyphs import Patches
from bokeh.models import (
    CustomJS,
    Range1d,
    ColumnDataSource,
    AutocompleteInput,
    TextInput,
    Button,
    Rect,
    Div,
    Styles,
    TablerIcon,
    HoverTool, 
    NumeralTickFormatter, 
    LabelSet,
    HoverTool,
)

from bokeh.plotting import show as bk_show
from bokeh.layouts import column, row
from bokeh.plotting import save as bk_save #Need to rename the bokeh show function so that there is no confusion with GenomeBrowser.show

import os
import warnings

# %% ../nbs/API/03_plot.ipynb 7
class GenomePlot():
    def __init__(self, browsers:Union["GenomeBrowser",List["GenomeBrowser"]], #a GenomeBrowser object or list of GenomeBrowser objects when a GenomeStack is rendered
                 output_backend:str="webgl" # can be "webgl" or "svg". webgl is more efficient but svg is a vectorial format that can be conveniently modified using other software
                ):
        '''A GenomePlot object is created to handle all the rendering logic of GenomeBrowser objects. An empty figure is created upon initialization. 
        Glyphs, sequence and search boxes are then added when calling GenomePlot._collect_elements.'''

        if isinstance(browsers, list):
            self.browser = browsers[0]
            if len(browsers) > 1:
                self.child_browsers = browsers[1:]
        else:
            self.browser = browsers
            self.child_browsers = []


        self.output_backend = output_backend
        self.elements = []
        self.tracks = []
        self.track_figs = []
        
        self._get_main_fig()

        for browser in self.child_browsers:
            pass # TODO: merge in GenomeStack.show()



    def _add_track(self, track):
        fig = track.get_fig(
                x_range=self.x_range, 
                width=self.browser.width, 
                bounds=self.browser.bounds,
                max_glyph_loading_range=self.browser.max_glyph_loading_range,
                output_backend=self.output_backend
            )
        self.elements.append(fig)
        self.track_figs.append(fig)
        self.tracks.append(track)
        
    def _get_main_fig(self):
        self._set_init_pos()
        if self.browser.init_win>self.browser.max_interval:
            warnings.warn("You requested an initial window larger than max_interval. Change max_interval to plot a larger window (this might overload your memory)")
        self.init_win = min(min(self.browser.init_win,self.browser.bounds[1]-self.browser.bounds[0]),self.browser.max_interval)

        semi_win = self.init_win / 2
            
        self.x_range = Range1d(
            max(self.browser.bounds[0],self.init_pos - semi_win), min(self.browser.bounds[1],self.init_pos + semi_win), 
            bounds=self.browser.bounds, 
            max_interval=self.browser.max_interval,
            min_interval=30
        )

        self.main_fig = figure(
            tools = "xwheel_zoom, xpan, save, reset",
            active_scroll = "xwheel_zoom",
            height = self.browser.height,
            x_range = self.x_range,
            y_range = Range1d(0, 1),
            output_backend=self.output_backend,
            **self.browser.kwargs
        )
        # Add tool
        self.main_fig.add_tools(BoxZoomTool(dimensions="width"))

        # Format x axis values
        self.main_fig.xaxis[0].formatter = NumeralTickFormatter(format="0,0")
        # Hide grid
        self.main_fig.xgrid.visible = False
        self.main_fig.ygrid.visible = False
        # Hide axis
        self.main_fig.yaxis.visible = False

        self.main_fig.frame_width=self.browser.width
        
        self.x_range
    
    def _set_init_pos(self):
        self.init_pos = self.browser.init_pos
        if self.init_pos == None:
            self.init_pos = sum(self.browser.bounds)//2
        elif self.init_pos > self.browser.bounds[1] or self.init_pos < self.browser.bounds[0]:
            warnings.warn("Requested an initial position outside of the browser bounds")
            self.init_pos = sum(self.browser.bounds)//2

# %% ../nbs/API/03_plot.ipynb 8
@patch
def _add_annotations(self:GenomePlot):
    """
    Creates the Bokeh ColumnDataSource objects for the glyphs and add the glyphs and labels to the main_fig
    """
    
    #Filter initial glyphs by position
    feature_patches = self.browser.patches.loc[(
        self.browser.patches['xs'].apply(
            lambda x: max(x)>self.x_range.start-self.browser.max_glyph_loading_range)) & (
        self.browser.patches['xs'].apply(
            lambda x: min(x)<self.x_range.end+self.browser.max_glyph_loading_range)
        )].copy()
    
    self._glyph_source = ColumnDataSource(feature_patches.to_dict(orient="list"))
    
    #Information about the range currently plotted
    self._loaded_range = ColumnDataSource({"start":[self.x_range.start-self.browser.max_glyph_loading_range],
                                            "end":[self.x_range.end+self.browser.max_glyph_loading_range], 
                                            "range":[self.browser.max_glyph_loading_range]})
    
    glyph_renderer = self.main_fig.add_glyph(
        self._glyph_source, Patches(xs="xs", ys="ys", fill_color="color", fill_alpha="alpha")
    )
    # gene labels in the annotation track
    # This seems to be necessary to show the labels
    #self.main_fig.scatter(x="label_x", y=0, size=0, source=self._glyph_source)
    
    #ys = list()
    
    if self.browser.show_labels:
        labels = LabelSet(
            x="label_x",
            y="label_y",
            text="names",
            level="glyph",
            x_offset=self.browser.label_horizontal_offset,
            y_offset=0,
            source=self._glyph_source,
            text_align='left',
            text_font_size=self.browser.label_font_size,
            angle=self.browser.label_angle,
        )

        self.main_fig.add_layout(labels)
    self.main_fig.add_tools(
        HoverTool(
            renderers=[glyph_renderer],
            tooltips="<div>@attributes</div>",
        )
    )

# %% ../nbs/API/03_plot.ipynb 10
@patch
def _get_sequence_div(self:GenomePlot):
        ## Setting the div that will display the sequence
        sty=Styles(font_size='14px',
                font_family="Courrier",
                color="black",
                display="inline-block",
                overflow="hidden",
                background_color = "white",
                margin="0",
                margin_left= "2px",
                )
        
        self._div = Div(height=18, height_policy="fixed", 
                        width=self.browser.width, 
                        max_width=self.browser.width,
                        width_policy="fixed",
                        styles = sty,
                        )

# %% ../nbs/API/03_plot.ipynb 12
@patch
def _set_js_callbacks(self:GenomePlot):
        ## Adding the ability to display the sequence when zooming in
        self.sequence_dic = {
            'seq': str(self.browser.seq).upper() if self.browser.show_seq else "",
            'bounds':self.browser.bounds,
        }

        self._xcb = CustomJS(
            args={
                "x_range": self.main_fig.x_range,
                "sequence": self.sequence_dic,
                "all_glyphs":self.browser.patches.to_dict(orient="list"),
                "glyph_source": self._glyph_source,
                "div": self._div,
                "loaded_range":self._loaded_range,
            },
            code=x_range_change_callback_code
        )
        
        self._glyph_update_callback = CustomJS(
            args={
                "x_range": self.main_fig.x_range,
                "all_glyphs":self.browser.patches.to_dict(orient="list"),
                "glyph_source": self._glyph_source,
                "loaded_range":self._loaded_range,
            },
            code=glyph_update_callback_code
        )

        self.main_fig.x_range.js_on_change('start', self._xcb, self._glyph_update_callback)

# %% ../nbs/API/03_plot.ipynb 14
@patch
def _get_browser_elements(self:GenomePlot):
        self._add_annotations() 
        self._get_sequence_div()
        self._set_js_callbacks()

        if self.browser.show_seq:
            self.elements = [self.main_fig,self._div]
        else:
            self.elements = [self.main_fig]

# %% ../nbs/API/03_plot.ipynb 16
@patch
def _get_search_box(self:GenomePlot):
        ## Create a text input widget for search
        completions=set()
        #for attr in self.patches.columns:
        #    if not attr in ["xs","ys","color","pos"]:
        #        completions.update(map(str,set(self.patches[attr])))
        completions.update(map(str,set(self.browser.patches["names"])))
        
        search_input = AutocompleteInput(completions=list(completions), placeholder="search by name")
        #search_input = TextInput()
        
        call_back_search = CustomJS(
            args={
                "x_range": self.x_range,
                "glyph_source": self._glyph_source,
                "bounds": self.browser.bounds,
                "all_glyphs": self.browser.patches.to_dict(orient="list"),
                "loaded_range": self._loaded_range,
                "div": self._div,
            },
            code=search_callback_code
        )

        search_input.js_on_change('value', call_back_search, self._xcb, self._glyph_update_callback)

        return search_input

# %% ../nbs/API/03_plot.ipynb 18
@patch
def _get_sequence_search(self:GenomePlot):
        """Returns a row of Bokeh elements containing the sequence search box a previous button and a next button"""

        seq_input = TextInput(placeholder="search by sequence")

        ## Adding BoxAnnotation to highlight search results
        search_span_source = ColumnDataSource({"x":[],"width":[],"fill_color":[]})#"y":[]
        h=Rect(x='x',y=0,
               width='width',
               height=self.main_fig.height,
               fill_color='fill_color',
               line_color="fill_color",
               fill_alpha=0.2,
               line_alpha=0.4)
        
        self.main_fig.add_glyph(search_span_source, h)

        call_back_sequence_search = CustomJS(
            args={
                "x_range": self.x_range,
                "sequence": self.sequence_dic,
                "bounds": self.browser.bounds,
                "search_span_source": search_span_source,
            },
            code=sequence_search_code
        )

        seq_input.js_on_change('value',call_back_sequence_search, self._xcb, self._glyph_update_callback)
        
        sty=Styles(
                   margin_left="1px",
                   margin_right="1px",
                   border = "none",
                   #width = "10px",
                )
        
        nextButton = Button(icon=TablerIcon("arrow-right"),
                            label="",
                            #button_type="primary",
                            styles = sty)
        
        nextButton_callback = CustomJS(
            args={
                "x_range": self.x_range,
                "bounds": self.browser.bounds,
                "search_span_source": search_span_source,
            },
            code=next_button_code)
        
        nextButton.js_on_event("button_click", nextButton_callback, self._xcb, self._glyph_update_callback)
        
        previousButton = Button(icon=TablerIcon("arrow-left"),
                                label="",
                                styles = sty,
                                #button_type="primary"
                               )
        
        previousButton_callback = CustomJS(
            args={
                "x_range": self.x_range,
                "bounds": self.browser.bounds,
                "search_span_source": search_span_source,
            },
            code=previous_button_code)
        
        previousButton.js_on_event("button_click", previousButton_callback, self._xcb, self._glyph_update_callback)

        return row(seq_input, previousButton, nextButton)

# %% ../nbs/API/03_plot.ipynb 20
@patch
def _collect_elements(self:GenomePlot):
    """collects and assembles all the main figure elements including the sequence div and search boxes"""
    self._get_browser_elements()
    elements = self.elements.copy()
    if self.browser.search:
        search_elements = [self._get_search_box()]
        if self.browser.show_seq:
            search_elements.append(self._get_sequence_search())
        elements = [row(search_elements)]+elements

    self.elements = elements
    for track in self.browser.tracks:
        self._add_track(track)

    for modifier in self.browser.modifiers:
        if modifier.gene_track:
            modifier.render(self.main_fig)
        if modifier.data_tracks:
            for i, track in enumerate(self.tracks):
                modifier.render(self.track_figs[i], True, track.__dict__)
