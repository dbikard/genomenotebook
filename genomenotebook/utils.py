# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/API/02_utils.ipynb.

# %% auto 0
__all__ = ['attributes', 'default_types', 'gene_y_range', 'default_glyphs', 'Y_RANGE', 'parse_gff', 'set_positions',
           'get_genome_annotations', 'extract_attribute', 'extract_all_attributes', 'available_feature_types',
           'available_attributes', 'attributes_to_columns', 'get_features_from_annotation', 'arrow_coordinates',
           'box_coordinates', 'get_patch_coordinates', 'get_feature_patches', 'get_y_range', 'get_all_glyphs',
           'create_genome_browser_plot', 'split_string']

# %% ../nbs/API/02_utils.ipynb 4
import numpy as np
import pandas as pd
import io

from bokeh.plotting import figure
from bokeh.models.tools import BoxZoomTool
from bokeh.models import HoverTool, NumeralTickFormatter, LabelSet
from bokeh.models.glyphs import Patches
from bokeh.models import (
    CustomJS,
    Range1d,
    ColumnDataSource,
)

from collections import defaultdict
import warnings

# %% ../nbs/API/02_utils.ipynb 5
def parse_gff(gff_path)->pd.DataFrame:
    cwd = os.getcwd()
    with open(gff_path,"r") as gff_file:
        # Create an in-memory file buffer using the io.StringIO class
        file_buffer = io.StringIO()
        for line in gff_file:
            if line[0]=="#":
                continue
            else:
                # Write each line to the file buffer
                file_buffer.write(line)
                
        # Reset the file pointer to the beginning of the file buffer
        file_buffer.seek(0)       

        df=pd.read_csv(file_buffer,sep="\t",header=None)
        df.columns=["seq_id", "source","type","start","end","score","strand","phase","attributes"]
        
    return df

# %% ../nbs/API/02_utils.ipynb 6
from .data import get_example_data_dir
import os

# %% ../nbs/API/02_utils.ipynb 8
def set_positions(annotation: pd.DataFrame, # an annotation DataFrame extracted from a gff file
                            ):
    """Sets left and right as the position of the feature on the sequence, left is always lower than right.
    start and end represent the begining and end of the feature where start can be greater than end depending on the feature strand.
    """
    annotation=annotation.copy()
    annotation.loc[:, "left"] = annotation[["start"]].values
    annotation.loc[:, "right"] = annotation[["end"]].values
    
    mask = annotation["strand"] == "+"
    annotation.loc[mask, "start"] = annotation.loc[mask, "left"].values
    annotation.loc[mask, "end"] = annotation.loc[mask, "right"].values
    
    mask = annotation["strand"] == "-"
    annotation.loc[mask, "start"] = annotation.loc[mask, "right"].values
    annotation.loc[mask, "end"] = annotation.loc[mask, "left"].values
    
    annotation["middle"] = (annotation.right + annotation.left) / 2
    
    return annotation

# %% ../nbs/API/02_utils.ipynb 10
def get_genome_annotations(gff_path: str, seq_id: str=None):
    """Parses a gff file and extracts the features that belong to seq_id. Raises a warning if resulting DataFrame is empty."""
    annotation = parse_gff(gff_path)
    if seq_id:
        annotation = annotation.loc[(annotation.seq_id == seq_id)]
        if len(annotation)==0:
            warnings.warn("The annotation DataFrame is empty. Check that the fasta and gff files have the same sequence id")
    
    annotation = set_positions(annotation)
    return annotation

# %% ../nbs/API/02_utils.ipynb 13
import re

# %% ../nbs/API/02_utils.ipynb 14
def extract_attribute(input_str:str, #attribute string to parse
                      attr_name:str, #name of the attribute to extract
                     ) -> str:
    """Extracts the attribute called attr_name from the GFF attributes string"""
    
    pattern = f"[{attr_name[0].lower()}{attr_name[0].upper()}]{attr_name[1:]}=(?P<{attr_name}>[^;]+)"
    match = re.search(pattern, input_str)
    if match:
        return match.groupdict()[attr_name]
    else:
        return None

# %% ../nbs/API/02_utils.ipynb 18
def extract_all_attributes(input_str:str)->dict:
    """Extracts all attributes from the GFF attributes column"""
    
    pattern = "(?P<key>\w+[-\w]*)=(?P<value>[^;]+)"
    match = re.findall(pattern, input_str)
    d=defaultdict()
    d.update(match)
    return d

# %% ../nbs/API/02_utils.ipynb 20
def available_feature_types(gff_path):
    features=parse_gff(gff_path)
    all_keys=set(features.type.values)
    return all_keys

# %% ../nbs/API/02_utils.ipynb 22
def available_attributes(gff_path):
    features=parse_gff(gff_path)
    attr_dicts=features.attributes.apply(extract_all_attributes)
    all_keys=list(set().union(*[d.keys() for d in attr_dicts]))
    return all_keys

# %% ../nbs/API/02_utils.ipynb 24
def attributes_to_columns(features: pd.DataFrame):
    attr_dicts=features.attributes.apply(extract_all_attributes)
    all_keys=list(set().union(*[d.keys() for d in attr_dicts]))
    
    attr_dict=dict([(k,[d.get(k,None) for d in attr_dicts]) for k in all_keys])
    features=features.copy()
    for k,v in attr_dict.items():
        features[k]=v
        
    return features
    

# %% ../nbs/API/02_utils.ipynb 27
attributes=["gene", "locus_tag", "product"]
default_types=["CDS", "repeat_region", "ncRNA", "rRNA", "tRNA"]
def get_features_from_annotation(annotation: pd.DataFrame, #annotation DataFrame extracted from GFF file
                                 feature_types: list = default_types, # list of feature types to extract
                                 attributes: list = attributes # list of attributes to extract
                                ):
    """Filters annotations to keep only features of type `feature_type`.
       Extracts each attribute from `attributes` as a column.
    """
    features = annotation[
        annotation.type.isin(feature_types)
    ].copy()
 
    for attr in attributes:
        features[attr] = features.attributes.apply(extract_attribute,attr_name=attr)
        
    features.loc[features.type == "repeat_region", "gene"] = "REP"
    features['gene_or_locus'] = features['gene'].fillna(features[attributes[0]])
    
    return features

# %% ../nbs/API/02_utils.ipynb 29
from collections import defaultdict

# %% ../nbs/API/02_utils.ipynb 30
gene_y_range = (-1.5, -1)

def arrow_coordinates(feature):
    feature_size = feature.right - feature.left
    
    if feature.strand=="+":
        arrow_base = feature.end - np.minimum(feature_size, 100)
    else:
        arrow_base = feature.end + np.minimum(feature_size, 100)
    
    xs=(feature.start,
        feature.start,
        arrow_base,
        feature.end,
        arrow_base
       )
    
    y_min, y_max = gene_y_range
    ys = (y_min, y_max, y_max, (y_max + y_min) / 2, y_min)
    return xs, ys

def box_coordinates(feature):
    xs=(feature.left, feature.left,
        feature.right, feature.right)
    y_min, y_max = gene_y_range
    ys = (y_min, y_max, y_max, y_min)
    return xs, ys

default_glyphs=defaultdict(lambda: ("arrow",("purple","orange"))) #the default glyph will be the same as for CDS etc.
default_glyphs.update(dict([(f,("arrow",("purple","orange"))) for f in ["CDS", "ncRNA", "rRNA", "tRNA"]]))
default_glyphs['repeat_region']=("box",("grey",))

def get_patch_coordinates(feature, # row of a pandas DataFrame extracted from a GFF file
                          patch_dict: dict = default_glyphs # a dictionnary containing as key a feature type and as value a patch definition.
                         ):
    """
    patchs are defined with a patch a tuple: (patch_type, (patch_color_plus, patch_color_minus)). 
    Different colors can be specified depending on the strand."""
    
    patch_type, patch_colors = patch_dict[feature.type]
    if len(patch_colors)>1:
        color_dic={"+":patch_colors[0],
                   "-":patch_colors[1]}
    else:
        color_dic=defaultdict(lambda: patch_colors[0])
        
    if patch_type=="arrow":
        return arrow_coordinates(feature), color_dic[feature.strand]
    elif patch_type=="box":
        return box_coordinates(feature), color_dic[feature.strand]
    
    

# %% ../nbs/API/02_utils.ipynb 33
def get_feature_patches(features: pd.DataFrame, #DataFrame of the features 
                        left: int, #left limit
                        right: int, #right limit
                        patch_dict: dict = default_glyphs, #glyphs to use for each feature type
                        attributes: list = attributes, #list of attributes to display when hovering
                        name: str = attributes[0] #attribute to be displayed as the feature name
                       ):
    features=features.loc[(features["right"] > left) & (features["left"] < right)]
    
    if len(features)>0:
        coordinates, colors = zip(*features.apply(get_patch_coordinates,patch_dict=patch_dict,axis=1))
        xs, ys = zip(*coordinates)
    else:
        colors = []
        xs, ys = [], []
    names = list(features[name].fillna("").values) #list(features.gene.fillna(features["locus_tag"]).values)
    out=dict(xs=xs,
             ys=ys,
             color=colors,
             pos=features.middle.values,
             names=names,
             hover_names=names,
            )

    out.update(features[attributes].to_dict(orient='list'))
    return out

 

# %% ../nbs/API/02_utils.ipynb 38
Y_RANGE = (-2, 2)
def get_y_range() -> tuple:
    """Accessor that returns the Y range for the genome browser plot
    """
    return Y_RANGE


# %% ../nbs/API/02_utils.ipynb 39
def get_all_glyphs(genes,bounds:tuple) -> dict:
    all_glyphs=get_gene_patches(genes, bounds[0], bounds[1])

    ks=list(all_glyphs.keys())
    ref_list_ix=ks.index('xs')
    # Sort all the lists in the dictionary based on the values of the reference list
    sorted_lists = sorted(zip(*[all_glyphs[k] for k in ks]), key= lambda x: x[ref_list_ix][0])

    # Convert the sorted tuples back into separate lists
    unzipped_lists = zip(*sorted_lists)

    # Create a new dictionary with the same keys as the original dictionary, but with the sorted lists as values
    all_glyphs = {k: list(t) for k, t in zip(ks, unzipped_lists)}
    
    return all_glyphs

# %% ../nbs/API/02_utils.ipynb 40
def create_genome_browser_plot(glyphSource, x_range, attributes=attributes, **kwargs):
    plot_height = kwargs.get("plot_height", 150)
    label_angle = kwargs.get("label_angle", 45)
    text_font_size = kwargs.get("text_font_size", "10pt")
    output_backend = kwargs.get("output_backend", "webgl")
    
    y_min, y_max = get_y_range()
    p_annot = figure(
        tools = "xwheel_zoom,xpan,save",
        active_scroll = "xwheel_zoom",
        height = plot_height,
        x_range = x_range,
        y_range = Range1d(y_min, y_max),
        output_backend=output_backend,
    )
    # Add tool
    p_annot.add_tools(BoxZoomTool(dimensions="width"))

    # Format x axis values
    p_annot.xaxis[0].formatter = NumeralTickFormatter(format="0,0")
    # Hide grid
    p_annot.xgrid.visible = False
    p_annot.ygrid.visible = False
    # Hide axis
    p_annot.yaxis.visible = False
    glyph = p_annot.add_glyph(
        glyphSource, Patches(xs="xs", ys="ys", fill_color="color")
    )
    # gene labels in the annotation track
    # This seems to be necessary to show the labels
    p_annot.scatter(x="pos", y=0, size=0, source=glyphSource)
    labels = LabelSet(
        x="pos",
        y=-0.9,
        text="names",
        level="glyph",
        angle=label_angle,
        text_font_size=text_font_size,
        x_offset=-5,
        y_offset=0,
        source=glyphSource,
        text_align='left',
    )

    p_annot.add_layout(labels)
    tooltips=[(attr,f"@{attr}") for attr in attributes]
    p_annot.add_tools(
        HoverTool(
            renderers=[glyph],
            tooltips=tooltips,
        )
    )
    return p_annot

# %% ../nbs/API/02_utils.ipynb 43
def split_string(string, max_length=10):
    if len(string) <= max_length:
        return string
    else:
        split_index = max_length
        while split_index > 0 and string[split_index] != ' ':
            split_index -= 1
        if split_index == 0:
            split_index = max_length  # If no suitable breaking point found, split at max_length
        return string[:split_index] + '\n' + split_string(string[split_index:].lstrip(), max_length)


