# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/API/02_utils.ipynb.

# %% auto 0
__all__ = ['default_types', 'default_attributes', 'is_gzipped_file', 'download_file', 'extract_attribute',
           'extract_all_attributes', 'attributes_to_columns', 'set_positions', 'default_open_gz', 'parse_gff',
           'available_feature_types', 'available_attributes', 'split_string', 'in_wsl', 'add_extension']

# %% ../nbs/API/02_utils.ipynb 5
import numpy as np
import pandas as pd
import io

from collections import defaultdict
import warnings
import gzip
import urllib.request
import os
import re
from platform import uname


# %% ../nbs/API/02_utils.ipynb 6
def is_gzipped_file(file_path):
    try:
        with gzip.open(file_path, 'rb') as f:
            # Attempt to read a small chunk from the file
            f.read(1)
        return True
    except IOError:
        return False
    
def download_file(url, save_path):
    if os.path.exists(save_path):
        print(f"File already exists: {save_path}")
    else:
        urllib.request.urlretrieve(url, save_path)
        print(f"File downloaded and saved: {save_path}")

# %% ../nbs/API/02_utils.ipynb 8
def extract_attribute(input_str:str, #attribute string to parse
                      attr_name:str, #name of the attribute to extract
                     ) -> str:
    """Extracts the attribute called attr_name from the GFF attributes string"""
    
    pattern = f"[{attr_name[0].lower()}{attr_name[0].upper()}]{attr_name[1:]}=(?P<{attr_name}>[^;]+)"
    match = re.search(pattern, input_str)
    if match:
        return match.groupdict()[attr_name]
    else:
        return None

# %% ../nbs/API/02_utils.ipynb 11
def extract_all_attributes(input_str:str)->dict:
    """Extracts all attributes from the GFF attributes column"""
    
    pattern = "(?P<key>\w+[-\w]*)=(?P<value>[^;]+)"
    match = re.findall(pattern, input_str)
    d=defaultdict()
    d.update(match)
    return d

# %% ../nbs/API/02_utils.ipynb 13
def attributes_to_columns(features: pd.DataFrame):
    attr_dicts=features.attributes.apply(extract_all_attributes)
    all_keys=list(set().union(*[d.keys() for d in attr_dicts]))
    
    attr_dict=dict([(k,[d.get(k,None) for d in attr_dicts]) for k in all_keys])
    features=features.copy()
    for k,v in attr_dict.items():
        features[k]=v
    
    features.fillna("")
    return features
    

# %% ../nbs/API/02_utils.ipynb 14
def set_positions(annotation: pd.DataFrame, # an annotation DataFrame extracted from a gff file
                            ):
    """Sets left and right as the position of the feature on the sequence, left is always lower than right.
    start and end represent the begining and end of the feature where start can be greater than end depending on the feature strand.
    """
    annotation=annotation.copy()
    annotation.loc[:, "left"] = annotation[["start"]].values
    annotation.loc[:, "right"] = annotation[["end"]].values
    
    mask = annotation["strand"] == "+"
    annotation.loc[mask, "start"] = annotation.loc[mask, "left"].values
    annotation.loc[mask, "end"] = annotation.loc[mask, "right"].values
    
    mask = annotation["strand"] == "-"
    annotation.loc[mask, "start"] = annotation.loc[mask, "right"].values
    annotation.loc[mask, "end"] = annotation.loc[mask, "left"].values
    
    annotation["middle"] = (annotation.right + annotation.left) / 2
    
    return annotation

# %% ../nbs/API/02_utils.ipynb 15
def default_open_gz(gff_path):
    if is_gzipped_file(gff_path):
        return gzip.open(gff_path,'rt')
    else:
        return open(gff_path,'r')
    

# %% ../nbs/API/02_utils.ipynb 16
default_types=["CDS", "repeat_region", "ncRNA", "rRNA", "tRNA"]
default_attributes=["gene", "locus_tag", "product"]


def parse_gff(gff_path:str, # path to the gff file
              seq_id: str=None, # sequence id (first column of the gff)
              bounds: tuple=None, # (left limit, right limit)
              feature_types: list = None, # list of feature types to extract
             )->pd.DataFrame:
    cwd = os.getcwd()
    
    with default_open_gz(gff_path) as gff_file:
        # Create an in-memory file buffer using the io.StringIO class
        file_buffer = io.StringIO()
        default_seq_id=None
        buffer_empty=True
        for line in gff_file:
            if line[0]=="#":
                continue
            else:
                r=line.split('\t')
                if not seq_id and not default_seq_id:
                    default_seq_id=r[0]
                    seq_id=r[0]
                if r[0]==seq_id:
                    if feature_types==None or r[2] in feature_types:
                        if bounds==None or (int(r[3])<bounds[1] and int(r[4])>bounds[0]):
                            # Write each line to the file buffer
                            file_buffer.write(line)
                            buffer_empty=False
                        
                
        # Reset the file pointer to the beginning of the file buffer
        file_buffer.seek(0)
        if buffer_empty:
            warnings.warn("The annotation DataFrame is empty. Check that the feature_types and seq_id are correct.")
            df=pd.DataFrame(columns=["seq_id", "source","type","start","end","score","strand","phase","attributes"])
        else:
            df=pd.read_csv(file_buffer,sep="\t",header=None)
            df.columns=["seq_id", "source","type","start","end","score","strand","phase","attributes"]
            df=attributes_to_columns(df)
            df=set_positions(df)
     
        return df

# %% ../nbs/API/02_utils.ipynb 18
def available_feature_types(gff_path):
    ftypes=set()
    with default_open_gz(gff_path) as handle:
        for line in handle:
            if line[0]!="#":
                r=line.split('\t')
                if len(r)==9:
                    ftypes.add(r[2])
    return ftypes

# %% ../nbs/API/02_utils.ipynb 21
def available_attributes(gff_path):
    features=parse_gff(gff_path)
    return features.columns

# %% ../nbs/API/02_utils.ipynb 24
from collections import defaultdict

# %% ../nbs/API/02_utils.ipynb 25
def split_string(string, max_length=10):
    if len(string) <= max_length:
        return string
    else:
        split_index = max_length
        while split_index > 0 and string[split_index] != ' ':
            split_index -= 1
        if split_index == 0:
            split_index = max_length  # If no suitable breaking point found, split at max_length
        return string[:split_index] + '\n' + split_string(string[split_index:].lstrip(), max_length)



# %% ../nbs/API/02_utils.ipynb 27
def in_wsl() -> bool:
    return 'microsoft-standard' in uname().release

# %% ../nbs/API/02_utils.ipynb 29
def add_extension(filename,extension="svg"):
    base_name, ext = os.path.splitext(filename)
    if ext.lower() != '.'+extension:
        filename += '.'+extension
    return filename
